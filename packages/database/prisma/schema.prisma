// Prisma schema for CocoBu

generator client {
  provider = "prisma-client-js"
  engineType = "library"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// Core Models
// ============================================================================

model User {
  id        String   @id @default(uuid()) @db.Char(36)
  userId    String   @map("user_id") @db.VarChar(64)
  name      String   @db.VarChar(255)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relationships
  ownedBooks     Book[]       @relation("BookOwner")
  memberships    Membership[]
  createdEntries Entry[]      @relation("EntryCreator")
  allocations    Allocation[]

  @@index([userId])
  @@map("users")
}

model Book {
  id        String   @id @default(uuid()) @db.Char(36)
  type      BookType
  name      String   @db.VarChar(255)
  // Currency should be ISO 4217 3-letter code (e.g., TWD, USD, JPY)
  // Validation enforced at application layer
  currency  String   @default("TWD") @db.Char(3)
  ownerId   String   @map("owner_id") @db.Char(36)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relationships
  owner       User         @relation("BookOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  memberships Membership[]
  entries     Entry[]
  settlements Settlement[]
  categories  Category[]

  @@map("books")
}

enum BookType {
  personal
  split
}

model Membership {
  id       String         @id @default(uuid()) @db.Char(36)
  bookId   String         @map("book_id") @db.Char(36)
  userId   String         @map("user_id") @db.Char(36)
  role     MembershipRole
  joinedAt DateTime       @default(now()) @map("joined_at")

  // Relationships
  book Book @relation(fields: [bookId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([bookId, userId])
  @@index([userId])
  @@index([bookId])
  @@map("memberships")
}

enum MembershipRole {
  owner
  admin
  writer
  reader
}

// ============================================================================
// Transaction Models
// ============================================================================

model Entry {
  id            String    @id @default(uuid()) @db.Char(36)
  bookId        String    @map("book_id") @db.Char(36)
  creatorId     String    @map("creator_id") @db.Char(36)
  amount        Decimal   @db.Decimal(19, 4)
  // Currency should be ISO 4217 3-letter code (e.g., TWD, USD, JPY)
  // Validation enforced at application layer
  currency      String    @db.Char(3)
  occurredOn    DateTime  @map("occurred_on") @db.Date
  categoryId    String?   @map("category_id") @db.Char(36)
  note          String?   @db.Text
  sourceEntryId String?   @map("source_entry_id") @db.Char(36)
  version       Int       @default(1)
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relationships
  book         Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)
  creator      User      @relation("EntryCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  category     Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  sourceEntry  Entry?    @relation("MirrorEntries", fields: [sourceEntryId], references: [id], onDelete: Cascade)
  mirrorEntries Entry[]   @relation("MirrorEntries")
  split        Split?

  @@index([bookId, occurredOn(sort: Desc)])
  @@index([creatorId])
  @@index([sourceEntryId])
  @@map("entries")
}

model Split {
  id        String    @id @default(uuid()) @db.Char(36)
  entryId   String    @unique @map("entry_id") @db.Char(36)
  mode      SplitMode
  createdAt DateTime  @default(now()) @map("created_at")

  // Relationships
  entry       Entry        @relation(fields: [entryId], references: [id], onDelete: Cascade)
  allocations Allocation[]

  @@map("splits")
}

enum SplitMode {
  ratio
  shares
  exact
}

model Allocation {
  id               String   @id @default(uuid()) @db.Char(36)
  splitId          String   @map("split_id") @db.Char(36)
  userId           String   @map("user_id") @db.Char(36)
  ratio            Decimal? @db.Decimal(5, 2) // 0-100
  shares           Int?
  exactAmount      Decimal? @map("exact_amount") @db.Decimal(19, 4)
  calculatedAmount Decimal  @map("calculated_amount") @db.Decimal(19, 4)

  // Relationships
  split Split @relation(fields: [splitId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([splitId])
  @@index([userId])
  @@map("allocations")
}

model Settlement {
  id          String   @id @default(uuid()) @db.Char(36)
  bookId      String   @map("book_id") @db.Char(36)
  periodStart DateTime @map("period_start") @db.Date
  periodEnd   DateTime @map("period_end") @db.Date
  payload     Json
  createdAt   DateTime @default(now()) @map("created_at")

  // Relationships
  book Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@index([bookId])
  @@map("settlements")
}

model Category {
  id     String  @id @default(uuid()) @db.Char(36)
  bookId String? @map("book_id") @db.Char(36)
  name   String  @db.VarChar(100)
  color  String? @db.VarChar(20)
  icon   String? @db.VarChar(50)

  // Relationships
  book    Book?   @relation(fields: [bookId], references: [id], onDelete: Cascade)
  entries Entry[]

  @@map("categories")
}

// ============================================================================
// Auth & Rate Limiting Tables
// ============================================================================

